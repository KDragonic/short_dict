import short_dict as SD # type: ignore

obj = {...}

result = SD(obj).go("работа", "времена", "начала").run()
# Это будет то же самое
result = obj.get("работа", {}).get("времена", {}).get("начала", {})

# --- Методы могут быть такие ---



# -=-=-=- методы которые обычно не изменяют структуру -=-=-=-

# Идёт по пути рекурсивно, если не было найдено вернёт {}
SD().go(**params)
# params может быть:

# 1. просто строкой
# 2. строкой с *, например [начало_рабоч*_*] может быть как [начало_рабочего_дня] или [начало_рабочей_недели]
# 3. можно передать метод по которому будет фильтрация происходить
# 4. спец символы:
#   > действует так же как и чисто [*], так как он входит во все сразу, чем больше символов подряд тем сильнее углубление [">>>>"] это будет 4 [">"]
# 5. Так же работает и с списками так что просто числа тоже работает
# 6. Для списков работает ["4:8:2"]
# 7. Так же работает количество символов ["{count:4..7}"] ["{count:6..}"] ["{count:..7}"]

SD().filter(**params) # Работает так же как и go только на одном уровне без вложений

# -=-=-=- Методы изменения структуры -=-=-=-

# Сделать dict плоским
SD().flat(...)
# Принимает несколько аргументов:
# 1. key_mode - изменяет названия ключа на полный путь к свойству и нужно указать разделитель, по умолчанию не изменяется названия ключа
# 2. max - количество на сколько глубоко делать список плоским
# 3. duplicate - что делать с дубликатами, будет несколько вариантов:
#   - [>_*] будет в конец подставлять число если нужно число с 0 слева то [_***], в зависимости от < или > будет выбрана сторона куда ставится
#   - random - будем выбрано случайное название



SD().count() # Посчитает количество, после этого нельзя использовать другие методы даже run (Так как он включает в себя его)

# Кончается цепочка команд, это чтобы выполнить их всех и получить результат, нужно чтобы не составить список действий и разом их выполнить
SD().run()